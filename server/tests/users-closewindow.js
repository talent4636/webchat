#!/usr/bin/env vows
/*jslint node: true, maxlen: 150, maxerr: 50, indent: 2 */
'use strict';

var vows = require('vows'),
    assert = require('assert'),
    request = require('request'),
    async = require('async'),
    fs = require('fs'),
    querystring = require('querystring'),
    baseurl = 'http://127.0.0.1:32773';

try {
  baseurl = fs.readFileSync(__dirname + '/../../serverurl', 'utf8').trim();
} catch (err) {}

vows.describe('User close his window')

.addBatch({
  'user1 and user2 join a channel, user1 close his window after 1 second, user2 check his messages each second': {
    topic: function () {
      var self = this;
      var tmsg = [];
      var j1 = request.jar();
      var j2 = request.jar();
      var cid = 'cidwindow1';
      var userdata1 = {};
      var userdata2 = {};

      // user1 auth
      request({
        method: 'GET',
        url: baseurl + '/server/auth',
        headers: { 'Pfc-Authorization': 'Basic '
                   + new Buffer("testwindow1:password").toString('base64') },
        jar: j1,
      }, function (err, res, body) {
        userdata1 = JSON.parse(body);

        // user1 join
        request({
          method: 'PUT',
          url: baseurl + '/server/channels/' + cid + '/users/' + userdata1.id,
          jar: j1,
        }, function (err, res, body) {
          
          // after 1 second, user1 close his window
          // (an event is generated by his window binded to a special route)
          setTimeout(function () {
            request({
              method: 'PUT',
              url: baseurl + '/server/users/' + userdata1.id + '/closed',
              jar: j1,
              json: 1,
            }, function (err, res, body) {
              userdata1.res = res;
            });
          }, 1000);
          
          // then user2 auth
          request({
            method: 'GET',
            url: baseurl + '/server/auth',
            headers: { 'Pfc-Authorization': 'Basic '
                       + new Buffer("testwindow2:password").toString('base64') },
            jar: j2,
          }, function (err, res, body) {
            userdata2 = JSON.parse(body);
            
            // user2 join
            request({
              method: 'PUT',
              url: baseurl + '/server/channels/' + cid + '/users/' + userdata2.id,
              jar: j2,
            }, function (err, res, body) {

              // user2 check pending message each seconds
              // (simulates the browser periodic refresh)
              // these requests makes the garbage collector active
              var nb_check = 3;
              function user2readmsg() {
                setTimeout(function () {
                  request({
                    method: 'GET',
                    url: baseurl + '/server/users/' + userdata2.id + '/pending/',
                    jar: j2,
                  }, function (err, res, body) {
                    tmsg = tmsg.concat(JSON.parse(body)); // get the timeout leave message of user1
                  });
                  if (nb_check--) {
                    user2readmsg();
                  } else {
                    self.callback(null, tmsg, userdata1, userdata2);
                  }
                }, 1000);
              }
              user2readmsg();
              
            });
            
          });
          
        });
      });
      
    },
    
    'server tells that user1 has leave because of a quit': function (error, tmsg, userdata1, userdata2) {
      assert.equal(userdata1.res.statusCode, 200);
      assert.lengthOf(tmsg, 1);
      assert.equal(tmsg[0].type, 'leave');
      assert.equal(tmsg[0].body, 'quit');
      assert.equal(tmsg[0].sender, userdata1.id);
    },
  },
})

.export(module);
